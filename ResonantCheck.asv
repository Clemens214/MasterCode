function [varargout] = ResonantCheck(Energies, totalSystem, GammaL, GammaR, SigmaL, SigmaR, options)
arguments
    Energies
    totalSystem
    GammaL
    GammaR
    SigmaL
    SigmaR
    options.fermiEnergy = 0
    options.eigEnergy = 0
    options.idxLead = floor(length(totalSystem)/2)
    options.idxSample = ceil(length(totalSystem)/2)
    options.Transmission = true
    options.Conductance = true
    options.Both = false
    options.plotMore = false
end
    idxLead = options.idxLead;
    idxSample = options.idxSample;
    % define the Energies
    Energy = options.fermiEnergy;
    EnergyDot = options.eigEnergy;
    EnergiesDot = Energies + EnergyDot;
    % calculate the Hamiltonian
    totalHamiltonian = totalSystem - SigmaL - SigmaR;
    
    %% calculate the Transmission
    if options.Transmission == true
    % calculate the Extended Molecule Transmission
    [T_NEGF] = calcEM(Energies, EnergyDot, totalSystem, GammaL, GammaR, idxSample);
    % calculate the Breit-Wigner Transmission
    [SigmaL_eff, GammaL_eff] = calcBWside(Energies, EnergyDot, totalHamiltonian, SigmaL, idxSample, idxLead, left=true);
    [SigmaR_eff, GammaR_eff] = calcBWside(Energies, EnergyDot, totalHamiltonian, SigmaR, idxSample, idxLead, right=true);
    [T_BW, Delta] = calcBWboth(Energies, EnergyDot, SigmaL_eff, SigmaR_eff, GammaL_eff, GammaR_eff);
    % plot the Transmission
    plotTransmission(Energies, T_NEGF.', T_BW.')
    if options.plotMore == true
        plotComparison(Energies, T_NEGF, T_BW, GammaL_eff, GammaR_eff, Delta, lengthLead=floor(length(totalSystem)/2))
    end
    end
    
    %% calculate the Conductance
    if options.Conductance == true
    % calculate the Extended Molecule Conductance
    [G_NEGF] = calcEM(Energy, EnergiesDot, totalSystem, GammaL, GammaR, idxSample);
    % calculate the Breit-Wigner Conductance
    [SigmaL_tmp, GammaL_tmp] = calcBWside(Energy, EnergiesDot, totalHamiltonian, SigmaL, idxSample, idxLead, left=true);
    [SigmaR_tmp, GammaR_tmp] = calcBWside(Energy, EnergiesDot, totalHamiltonian, SigmaR, idxSample, idxLead, right=true);
    [G_BW] = calcBWboth(Energy, EnergiesDot, SigmaL_tmp, SigmaR_tmp, GammaL_tmp, GammaR_tmp);
    % plot the Conductance
    plotConductance(EnergiesDot, G_NEGF, G_BW)
    end
    
    %% calculate Both
    if options.Both == true
    % calculate Both for the Extended Molecule
    [G_NEGF] = calcEM(Energies, EnergiesDot, totalSystem, GammaL, GammaR, idxSample);
    % calculate Both for the Breit-Wigner Method
    [SigmaL_tmp, GammaL_tmp] = calcBWside(Energies, EnergiesDot, totalHamiltonian, SigmaL, idxSample, idxLead, left=true);
    [SigmaR_tmp, GammaR_tmp] = calcBWside(Energies, EnergiesDot, totalHamiltonian, SigmaR, idxSample, idxLead, right=true);
    [G_BW] = calcBWboth(Energies, EnergiesDot, SigmaL_tmp, SigmaR_tmp, GammaL_tmp, GammaR_tmp);
    % plot the Conductance
    plotBoth(Energies, EnergiesDot, G_NEGF, G_BW, logPlot=false)
    end
    
    %% return the Data
    % other outputs
    varargout{1} = G_NEGF;
    varargout{2} = G_BW;
    varargout{3} = T_NEGF;
    varargout{4} = T_BW;
    varargout{5} = GammaL_eff;
    varargout{6} = GammaR_eff;
    varargout{7} = Delta;
end

%% -------------------- Functions: EM -------------------- 
function [Results] = calcEM(Energies, EnergiesDot, totalSystem, GammaL, GammaR, idxSample, options)
arguments
    Energies
    EnergiesDot
    totalSystem
    GammaL
    GammaR
    idxSample
    options.useEta = false
end
    eta = 1j*1e-12;
    % We'll compute T(EF) for each gate (shift dot onsite)
    % Energy loop: compute GR (full) & projections
    Results = zeros(length(Energies), length(EnergiesDot));
    for ii = 1:length(Energies)
        Energy = Energies(ii);
        for kk = 1:length(EnergiesDot)
            EnergyDot = EnergiesDot(kk);
            % Update dot onsite in H and recompute dot GR for NEGF
            H = totalSystem;
            H(idxSample, idxSample) = H(idxSample, idxSample) + EnergyDot;
            % Full Green's function with both absorbers
            if options.useEta == false
                GreensR = (Energy*eye(size(H)) - H) \ eye(size(H));
            elseif options.useEta == true
                GreensR = ((Energy+eta)*eye(size(H)) - H) \ eye(size(H));
            end
            GreensA = GreensR';
            % NEGF transmission (matrix formula)
            Results(ii, kk) = real(trace(GammaL * GreensR * GammaR * GreensA));
        end
    end
end

%% -------------------- Functions: BW -------------------- 
function [SigmaDot, GammaDot] = calcBWside(Energies, EnergiesDot, totalHamiltonian, Sigma, idxSample, idxLead, options)
arguments
    Energies
    EnergiesDot
    totalHamiltonian
    Sigma
    idxSample
    idxLead
    options.left = false;
    options.right = false;
    options.useEta = false
end
    eta = 1j*1e-12;
    if options.left == true && options.right == false
        idx = idxLead+1;
    elseif options.left == false && options.right == true
        idx = length(totalHamiltonian) - idxLead;
    else
        idx = ceil(length(totalHamiltonian)/2);
    end
    disp(['calcBWside:',' Left: ',num2str(idxLead+1), ...
                        ', Right: ',num2str(length(totalHamiltonian) - idxLead), ...
                        ', Middle: ',num2str(ceil(length(totalHamiltonian)/2))])
    SigmaDot = zeros(length(Energies), length(EnergiesDot));
    GammaDot = zeros(length(Energies), length(EnergiesDot));
    totalSystem = totalHamiltonian + Sigma;
    for ii = 1:length(Energies)
        Energy = Energies(ii);
        for kk = 1:length(EnergiesDot)
            EnergyDot = EnergiesDot(kk);
            % Update dot onsite in H and recompute dot GR at EF for NEGF (full)
            H = totalSystem;
            H(idxSample, idxSample) = H(idxSample, idxSample) + EnergyDot;
            %compute the dot Green's function for one-side-only absorber
            if options.useEta == false
                GreensR = (Energy*eye(size(H)) - H) \ eye(size(H));
            elseif options.useEta == true
                GreensR = ((Energy+eta)*eye(size(H)) - H) \ eye(size(H));
            end
            GreensDot = GreensR(idx, idx);
            % effective self-energy due to lead as seen by dot
            SigmaDot(ii, kk) = Energy - EnergyDot - 1/GreensDot;
            % Extract Gammas and shift (energy dependent)
            GammaDot(ii, kk) = -2 * imag(SigmaDot(ii));
        end
    end
end

function [Results, varargout] = calcBWboth(Energies, EnergiesDot, SigmaL, SigmaR, GammaL, GammaR)
    Results = zeros(length(Energies), length(EnergiesDot));
    Delta = zeros(length(Energies), length(EnergiesDot));
    for ii = 1:length(Energies)
        Energy = Energies(ii);
        for kk = 1:length(EnergiesDot)
            EnergyDot = EnergiesDot(kk);
            % Effective total self-energy from both sides
            Sigma = SigmaL(ii, kk) + SigmaR(ii, kk);
            % Extract Gammas (energy dependent)
            Gamma = GammaL(ii, kk) + GammaR(ii, kk);
            % Extract shift (energy dependent)
            Delta(ii, kk) = real(Sigma);  
            % level shift = Re Sigma_eff_total
            
            % Breit-Wigner transmission using extracted Gammas and shift
            Results(ii, kk) = (GammaL(ii, kk) * GammaR(ii, kk)) / ((Energy - EnergyDot - Delta(ii, kk))^2 + (Gamma/2)^2);
        end
    end
    varargout{1} = Delta;
end

%% -------------------- Plotting functions -------------------- 
function [] = plotTransmission(Energies, T_NEGF, T_BW, options)
arguments
    Energies
    T_NEGF
    T_BW
    options.logPlot = true;
end
    % fit a Lorentzian to the Data
    LorentzFunc = fittype("a/pi * g/((x-x0)^2 + g^2)", dependent="y",independent="x", coefficients=["a", "g", "x0"]);
    LorentzFit = fit(Energies.' ,T_NEGF.' , LorentzFunc, StartPoint=[1, 1, 0]);
    yFit = LorentzFit(Energies);
    % plot the Data
    figure('Name','Energy sweep', 'NumberTitle','off');
    if options.logPlot == true
        semilogy(Energies, T_BW, DisplayName='T_{BW}');%, '--');
        hold on;
        semilogy(Energies, T_NEGF, DisplayName='T_{NEGF}');
        semilogy(Energies, yFit, '--', DisplayName='Fit');
    else
        plot(Energies, T_BW, DisplayName='T_{BW}');%, '--');
        hold on;
        plot(Energies, T_NEGF, DisplayName='T_{NEGF}');
        plot(Energies, yFit, '--', DisplayName='Fit');
    end
    hold off;
    % labels
    xlabel('\epsilon_d');
    xlabel('Energy (units of t)');
    ylabel('Transmission (2e/h)');
    legend('Location','Best');
    title('Transmission: full NEGF vs Breit–Wigner using EM-extracted \Gamma_{L,R}');
    grid on;
end

function [] = plotConductance(Energies, G_NEGF, G_BW, options)
arguments
    Energies
    G_NEGF
    G_BW
    options.logPlot = true;
end
    % fit a Lorentzian to the Data
    LorentzFunc = fittype("a/pi * g/((x-x0)^2 + g^2)", dependent="y",independent="x", coefficients=["a", "g", "x0"]);
    LorentzFit = fit(Energies.' ,G_NEGF.' , LorentzFunc, StartPoint=[1, 1, 0]);
    yFit = LorentzFit(Energies);
    % plot the Data
    figure('Name','Gate sweep', 'NumberTitle','off');
    if options.logPlot == true
        semilogy(Energies, G_BW, DisplayName='G_{BW}');%, '--');
        hold on;
        semilogy(Energies, G_NEGF, DisplayName='G_{NEGF}');
        semilogy(Energies, yFit, '--', DisplayName='Fit');
    else
        plot(Energies, G_BW, DisplayName='G_{BW}');%, '--');
        hold on;
        plot(Energies, G_NEGF, DisplayName='G_{NEGF}');
        plot(Energies, yFit, '--', DisplayName='Fit');
    end
    hold off;
    % labels
    xlabel('\epsilon_d');
    ylabel('G / G_0');
    legend('Location','Best');
    title('Gate sweep: NEGF (EM) vs Breit–Wigner using EM-extracted \Gamma_{L,R}');
    grid on;
end

function [] = plotBoth(Energies, EnergiesDot, NEGF, BW, options)
arguments
    Energies
    EnergiesDot
    NEGF
    BW
    options.logPlot = true;
end
    % prepare the data for fitting
    [xData, yData] = meshgrid(Energies, EnergiesDot);
    xData = xData(:);
    yData = yData(:);
    zData = NEGF(:);
    % Initial parameter guesses
    maxVal = 1;
    gamma = 1;
    x0 = mean(xData);
    y0 = mean(yData);
    initVals = [maxVal, gamma, x0, y0];
    % Perform the fit
    xyData = [xData, yData];
    LorentzFunc = @(p, xy) Lorentzian(xy(:,1), xy(:,2), p);
    fitVals = lsqcurvefit(LorentzFunc, initVals, xyData, zData);

    % Compute fitted surface for visualization
    zFit = lorentz2D(fitVals, xData, yData);

    % plot the Data
    figure('Name','Energy sweep', 'NumberTitle','off');
    if options.logPlot == true
        semilogy(Energies, BW, DisplayName='T_{BW}');%, '--');
        hold on;
        semilogy(Energies, NEGF, DisplayName='T_{NEGF}');
        semilogy(Energies, yFit, '--', DisplayName='Fit');
    else
        plot(Energies, BW, DisplayName='T_{BW}');%, '--');
        hold on;
        plot(Energies, NEGF, DisplayName='T_{NEGF}');
        plot(Energies, yFit, '--', DisplayName='Fit');
    end
    hold off;
    % labels
    xlabel('\epsilon_d');
    xlabel('Energy (units of t)');
    ylabel('Transmission (2e/h)');
    legend('Location','Best');
    title('Transmission: full NEGF vs Breit–Wigner using EM-extracted \Gamma_{L,R}');
    grid on;
end

function [] = plotComparison(Energies, T_NEGF, T_BW, GammaL, GammaR, Delta, options)
arguments
    Energies
    T_NEGF
    T_BW
    GammaL
    GammaR
    Delta
    options.lengthLead = NaN
end
    % -------------------- Plots --------------------
    figure('Name','Transmission comparison', 'NumberTitle','off');%,'Position',[100 100 900 700]);
    
    % 1st subplot
    subplot(3,1,1);
    hold on;
    plot(Energies, T_NEGF);
    plot(Energies, T_BW);% '--');
    hold off;
    xlabel('Energy (units of t)');
    ylabel('T(E)');
    legend('T_{NEGF}','T_{BW (EM)}','Location','Best');
    title('Transmission: full NEGF vs Breit–Wigner using EM-extracted \Gamma_{L,R}');
    grid on;
    
    % 2nd subplot
    subplot(3,1,2);
    hold on;
    plot(Energies, GammaL);
    plot(Energies, GammaR);
    plot(Energies, GammaL + GammaR, ':k');
    hold off;
    xlabel('Energy');
    ylabel('\Gamma(E)');
    legend('\Gamma_L','\Gamma_R','\Gamma_{tot}','Location','Best');
    title('Effective broadenings (projected to dot) computed from EM');
    grid on;
    
    % 3rd subplot
    subplot(3,1,3);
    plot(Energies, Delta);
    xlabel('Energy');
    ylabel('\Delta(E) = Re[\Sigma^{eff}_L + \Sigma^{eff}_R]');
    title('Effective level shift');
    grid on;
    
    % Title
    if ~isnan(options.lengthLead)
        sgtitle(sprintf('EM size: %d sites each lead', options.lengthLead));
    end
end

%% -------------------- Obsolete functions -------------------- 
function [zData] = Lorentzian(xData, yData, Vals, options)
arguments
    xData
    yData
    Vals
    options.fit = false
end
    ValCells = num2cell(Vals);
    [max, gamma, x0, y0] = ValCells{:};
    zData = zeros(length(xData), length(yData));
    for i = 1:length(xData)
        for j = 1:length(yData)
            % max       -> maximum value of the function
            % 2*gamma   -> half-width at half-maximum (HWHM)
            % x0, y0    -> shifts the peak of the distribution
            yData(i) = max/pi * gamma/((xData(i)-x0)^2 + (yData(j)-y0)^2 + gamma^2);
        end
    end
    if options.fit == true
        
    end
end