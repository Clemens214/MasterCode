function [G_NEGF, G_BW, varargout] = ResonantCheck(Energies, totalSystem, GammaL, GammaR, SigmaL, SigmaR, options)
arguments
    Energies
    totalSystem
    GammaL
    GammaR
    SigmaL
    SigmaR
    options.fermiEnergy = 0
    options.eigEnergy = 0
    options.idxLead = floor(length(totalSystem)/2)
    options.idxSample = ceil(length(totalSystem)/2)
    options.plotMore = false
end
    idxLead = options.idxLead;
    idxSample = options.idxSample;

    % define the Energies
    Energy = options.fermiEnergy;
    EnergyDot = options.eigEnergy;
    EnergiesDot = Energies + EnergyDot;
    
    % calculate the Hamiltonian
    totalHamiltonian = totalSystem - SigmaL - SigmaR;
    
    %% calculate the EM Data
    % calculate the Extended Molecule Transmission
    [T_NEGF] = calcEM(Energies, totalSystem, GammaL, GammaR);

    % calculate the Extended Molecule Conductance
    [G_NEGF] = sweepEM(EnergiesDot, totalSystem, GammaL, GammaR, Energy, idxSample);
    
    %% calculate the Breit-Wigner Data
    % calculate the Breit-Wigner Transmission
    [SigmaL_eff, GammaL_eff] = calcBWside(Energies, totalHamiltonian, SigmaL, EnergyDot, idxLead, left=true);
    [SigmaR_eff, GammaR_eff] = calcBWside(Energies, totalHamiltonian, SigmaR, EnergyDot, idxLead, right=true);
    
    [T_BW, Delta] = calcBWboth(Energies, SigmaL_eff, SigmaR_eff, GammaL_eff, GammaR_eff, EnergyDot);

    % calculate the Breit-Wigner Conductance
    [SigmaL_tmp, GammaL_tmp] = sweepBWside(EnergiesDot, totalHamiltonian, SigmaL, Energy, idxSample, idxLead, left=true);
    [SigmaR_tmp, GammaR_tmp] = sweepBWside(EnergiesDot, totalHamiltonian, SigmaR, Energy, idxSample, idxLead, right=true);
    
    [G_BW] = sweepBWboth(EnergiesDot, SigmaL_tmp, SigmaR_tmp, GammaL_tmp, GammaR_tmp, Energy);
    
    %% plot the Data
    % plot the results
    plotTransmission(Energies, T_NEGF, T_BW)
    plotConductance(EnergiesDot, G_NEGF, G_BW)
    if options.plotMore == true
        plotComparison(Energies, T_NEGF, T_BW, GammaL_eff, GammaR_eff, Delta, lengthLead=floor(length(totalSystem)/2))
    end

    %% return the Data
    % other outputs
    varargout{1} = T_NEGF;
    varargout{2} = T_BW;
    varargout{3} = GammaL_eff;
    varargout{4} = GammaR_eff;
    varargout{5} = Delta;
end

%% -------------------- Transmission functions: EM -------------------- 
function [T_NEGF] = calcEM(Energies, H, GammaL, GammaR, options)
arguments
    Energies
    H
    GammaL
    GammaR
    options.useEta = false
end
    eta = 0;%1j*1e-12;
    % Energy loop: compute GR (full) & projections
    T_NEGF = zeros(size(Energies));    % NEGF full transmission
    for ii = 1:length(Energies)
        Energy = Energies(ii);
        % Full Green's function with both absorbers
        if options.useEta == false
            GreensR = (Energy*eye(size(H)) - H) \ eye(size(H));
        elseif options.useEta == true
            GreensR = ((Energy+eta)*eye(size(H)) - H) \ eye(size(H));
        end
        GreensA = GreensR';
        % NEGF transmission (matrix formula)
        T_NEGF(ii) = real(trace(GammaL * GreensR * GammaR * GreensA));
    end
end

%% -------------------- Transmission functions: BW -------------------- 
function [SigmaDot, GammaDot] = calcBWside(Energies, totalHamiltonian, Sigma, EnergyDot, idxLead, options)
arguments
    Energies
    totalHamiltonian
    Sigma
    EnergyDot
    idxLead
    options.left = false
    options.right = false
    options.useEta = false
end
    eta = 0;%1j*1e-12;
    if options.left == true && options.right == false
        idx = idxLead+1;
    elseif options.left == false && options.right == true
        idx = length(totalHamiltonian) - idxLead;
    else
        idx = ceil(length(totalHamiltonian)/2);
    end
    SigmaDot = zeros(size(Energies));
    GammaDot = zeros(size(Energies));
    H = totalHamiltonian + Sigma;
    for ii = 1:length(Energies)
        Energy = Energies(ii);
        %compute the dot Green's function for one-side-only absorber
        if options.useEta == false
            GreensR = (Energy*eye(size(H)) - H) \ eye(size(H));
        elseif options.useEta == true
            GreensR = ((Energy+eta)*eye(size(H)) - H) \ eye(size(H));
        end
        GreensDot = GreensR(idx, idx);
        % effective self-energy due to lead as seen by dot
        SigmaDot(ii) = Energy - EnergyDot - 1/GreensDot;
        % Extract Gammas and shift (energy dependent)
        GammaDot(ii) = -2 * imag(SigmaDot(ii));
    end
end

function [T_BW, Delta] = calcBWboth(Energies, SigmaL, SigmaR, GammaL, GammaR, EnergyDot)
    T_BW   = zeros(size(Energies));
    Delta = zeros(size(Energies));
    for ii = 1:length(Energies)
        Energy = Energies(ii);
        % Effective total self-energy from both sides
        Sigma = SigmaL(ii) + SigmaR(ii);
        % Extract Gammas (energy dependent)
        Gamma = GammaL(ii) + GammaR(ii);
        % Extract shift (energy dependent)
        Delta(ii) = real(Sigma);  
        % level shift = Re Sigma_eff_total
        
        % Breit-Wigner transmission using extracted Gammas and shift
        T_BW(ii) = (GammaL(ii) * GammaR(ii)) / ((Energy - EnergyDot - Delta(ii))^2 + (Gamma/2)^2);
    end
end

%% -------------------- Conductance functions: EM -------------------- 
function [G_NEGF] = sweepEM(EnergiesDot, totalSystem, GammaL, GammaR, Energy, idxSample, options)
arguments
    EnergiesDot
    totalSystem
    GammaL
    GammaR
    Energy
    idxSample
    options.useEta = false
end
    eta = 0;%1j*1e-12;
    % We'll compute T(EF) for each gate (shift dot onsite)
    G_NEGF = zeros(size(EnergiesDot));
    for k = 1:length(EnergiesDot)
        EnergyDot = EnergiesDot(k);
        % Update dot onsite in H and recompute dot GR at EF for NEGF (full)
        H = totalSystem;
        H(idxSample, idxSample) = H(idxSample, idxSample) + EnergyDot;
        % Full Green's function with both absorbers at EF
        if options.useEta == false
            GreensR = (Energy*eye(size(H)) - H) \ eye(size(H));
        elseif options.useEta == true
            GreensR = ((Energy+eta)*eye(size(H)) - H) \ eye(size(H));
        end
        GreensA = GreensR';
        % NEGF conductance (matrix formula)
        G_NEGF(k) = real(trace(GammaL * GreensR * GammaR * GreensA));
    end
end

%% -------------------- Conductance functions: BW -------------------- 
function [SigmaDot, GammaDot] = sweepBWside(EnergiesDot, totalHamiltonian, Sigma, Energy, idxSample, idxLead, options)
arguments
    EnergiesDot
    totalHamiltonian
    Sigma
    Energy
    idxSample
    idxLead
    options.left = false;
    options.right = false;
    options.useEta = false
end
    eta = 0;%1j*1e-12;
    if options.left == true && options.right == false
        idxL = idxLead+1;
    elseif options.left == false && options.right == true
        idxR = length(totalHamiltonian) - idxLead;
    else
        idxM = ceil(length(totalHamiltonian)/2);
    end
    disp(['sweepBWside:',' Left: ',num2str(idxLead+1), ...
                        ', Right: ',num2str(length(totalHamiltonian) - idxLead),', Middle'])
    SigmaDot = zeros(size(EnergiesDot));
    GammaDot = zeros(size(EnergiesDot));
    totalSystem = totalHamiltonian + Sigma;
    for k = 1:length(EnergiesDot)
        EnergyDot = EnergiesDot(k);
        % Update dot onsite in H and recompute dot GR at EF for NEGF (full)
        H = totalSystem;
        H(idxSample, idxSample) = H(idxSample, idxSample) + EnergyDot;
        % compute the dot Green's function for one-side-only absorber
        if options.useEta == false
            GreensR = (Energy*eye(size(H)) - H) \ eye(size(H));
        elseif options.useEta == true
            GreensR = ((Energy+eta)*eye(size(H)) - H) \ eye(size(H));
        end
        GreensDot = GreensR(idx, idx);
        % effective self-energy due to lead as seen by dot
        SigmaDot(k) = Energy - EnergyDot - 1/GreensDot;
        % Extract Gammas and shift (energy dependent)
        GammaDot(k) = -2 * imag(SigmaDot(k));
    end
end

function [G_BW, varargout] = sweepBWboth(EnergiesDot, SigmaL, SigmaR, GammaL, GammaR, Energy)
    G_BW = zeros(size(EnergiesDot));
    Delta = zeros(size(EnergiesDot));
    for ii = 1:length(EnergiesDot)
        EnergyDot = EnergiesDot(ii);
        % Effective total self-energy from both sides
        Sigma = SigmaL(ii) + SigmaR(ii);
        % Extract Gammas (energy dependent)
        Gamma = GammaL(ii) + GammaR(ii);
        % Extract shift (energy dependent)
        Delta(ii) = real(Sigma);
        % level shift = Re Sigma_eff_total
    
        % Breit-Wigner conductance using extracted Gammas and shift
        G_BW(ii) = (GammaL(ii) * GammaR(ii)) / ((Energy - EnergyDot - Delta(ii))^2 + (Gamma/2)^2);
    end
    varargout{1} = Delta;
end

%% -------------------- Plotting functions -------------------- 
function [] = plotTransmission(Energies, T_NEGF, T_BW, options)
arguments
    Energies
    T_NEGF
    T_BW
    options.logPlot = true;
end
    % fit a Lorentzian to the Data
    LorentzFunc = fittype("a/pi * g/((x-x0)^2 + g^2)", dependent="y",independent="x", coefficients=["a", "g", "x0"]);
    LorentzFit = fit(Energies.' ,T_NEGF.' , LorentzFunc, StartPoint=[1, 1, 0]);
    yFit = LorentzFit(Energies);
    % plot the Data
    figure('Name','Energy sweep', 'NumberTitle','off');
    if options.logPlot == true
        semilogy(Energies, T_BW);% '--');
        hold on;
        semilogy(Energies, T_NEGF);
        semilogy(Energies, yFit, '--');
    else
        plot(Energies, T_BW);% '--');
        hold on;
        plot(Energies, T_NEGF);
        plot(Energies, yFit, '--');
    end
    hold off;
    % labels
    xlabel('\epsilon_d');
    xlabel('Energy (units of t)');
    ylabel('Transmission (\frac{2e}{h})');
    legend('T_{NEGF}','T_{BW (EM)}','Fit', 'Location','Best');
    title('Transmission: full NEGF vs Breit–Wigner using EM-extracted \Gamma_{L,R}');
    grid on;
end

function [] = plotConductance(Energies, G_NEGF, G_BW, options)
arguments
    Energies
    G_NEGF
    G_BW
    options.logPlot = true;
end
    % fit a Lorentzian to the Data
    LorentzFunc = fittype("a/pi * g/((x-x0)^2 + g^2)", dependent="y",independent="x", coefficients=["a", "g", "x0"]);
    LorentzFit = fit(Energies.' ,G_NEGF.' , LorentzFunc, StartPoint=[1, 1, 0]);
    yFit = LorentzFit(Energies);
    % plot the Data
    figure('Name','Gate sweep', 'NumberTitle','off');
    if options.logPlot == true
        semilogy(Energies, G_BW);% '--');
        hold on;
        semilogy(Energies, G_NEGF);
        semilogy(Energies, yFit, '--');
    else
        plot(Energies, G_BW);% '--');
        hold on;
        plot(Energies, G_NEGF);
        plot(Energies, yFit, '--');
    end
    hold off;
    % labels
    xlabel('\epsilon_d');
    ylabel('G / G_0');
    legend('G_{NEGF}','G_{BW}','Fit','Location','Best');
    title('Gate sweep: NEGF (EM) vs Breit–Wigner using EM-extracted \Gamma');
    grid on;
end

function [] = plotComparison(Energies, T_NEGF, T_BW, GammaL, GammaR, Delta, options)
arguments
    Energies
    T_NEGF
    T_BW
    GammaL
    GammaR
    Delta
    options.lengthLead = NaN
end
    % -------------------- Plots --------------------
    figure('Name','Transmission comparison', 'NumberTitle','off');%,'Position',[100 100 900 700]);
    
    % 1st subplot
    subplot(3,1,1);
    hold on;
    plot(Energies, T_NEGF);
    plot(Energies, T_BW);% '--');
    hold off;
    xlabel('Energy (units of t)');
    ylabel('T(E)');
    legend('T_{NEGF}','T_{BW (EM)}','Location','Best');
    title('Transmission: full NEGF vs Breit–Wigner using EM-extracted \Gamma_{L,R}');
    grid on;
    
    % 2nd subplot
    subplot(3,1,2);
    hold on;
    plot(Energies, GammaL);
    plot(Energies, GammaR);
    plot(Energies, GammaL + GammaR, ':k');
    hold off;
    xlabel('Energy');
    ylabel('\Gamma(E)');
    legend('\Gamma_L','\Gamma_R','\Gamma_{tot}','Location','Best');
    title('Effective broadenings (projected to dot) computed from EM');
    grid on;
    
    % 3rd subplot
    subplot(3,1,3);
    plot(Energies, Delta);
    xlabel('Energy');
    ylabel('\Delta(E) = Re[\Sigma^{eff}_L + \Sigma^{eff}_R]');
    title('Effective level shift');
    grid on;
    
    % Title
    if ~isnan(options.lengthLead)
        sgtitle(sprintf('EM size: %d sites each lead', options.lengthLead));
    end
end

%% -------------------- Obsolete functions -------------------- 
function [yData] = Lorentzian(xData, max, gamma, x0)
    yData = zeros(size(xData));
    for i = 1:length(xData)
        % max       -> maximum value of the function
        % 2*gamma   -> half-width at half-maximum (HWHM)
        % x0        -> shifts the peak of the distribution
        yData(i) = max/pi * gamma/((xData-x0)^2 + gamma^2);
    end
end