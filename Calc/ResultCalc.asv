function [varargout] = ResultCalc(Matrices, Factors, totalSystem, totalSysDeriv, gammaL, gammaR, options)
    %calculates the transport through by a molecule as calculated in the PhD-Thesis
    arguments
        Matrices
        Factors
        totalSystem
        totalSysDeriv
        gammaL
        gammaR
        options.linearResponse = false
        options.Transmission = false
        options.Torque = false
    end
    
    % determine whether the calculation is to be done using linear response
    if options.linearResponse == false
        TransmissionMatrix = mult(Eigenvals, leftEVs, rightEVs, gammaL, gammaR, chemPots);
    else
        TransmissionMatrix = linearApprox(totalSystem, totalSysDeriv, gammaL, gammaR, ...
                                        Transmission=options.Transmission, Torque=options.Torque);
    end
    %disp('Finished calculation of the current.')
    Traces = allTrace(real(TransmissionMatrix));
    Result = Traces(options.evalIndex);
end

%% transmission
function [Result] = mult(Matrices, Factors)
    for i 
    
    Result = zeros(length(Eigenvals), length(Eigenvals));
    for idx = 1:numel(index)
        Result = Result + Matrices{idx}*Factors(idx);
    end
end

%% linear transport approximation
function [varargout] = linearApprox(totalSystem, totalSysDeriv, gammaL, gammaR, options)
    % calculate the transmission and torque in the linear transport approximation
    arguments
        totalSystem
        totalSysDeriv
        gammaL
        gammaR
        options.Transmission = false
        options.Torque = false
    end
        
    if options.Transmission == true && options.Torque == false
        TransMatrix = TransmissionZeroTemp(totalSystem, gammaL, gammaR);
        
        varargout{1} = TransMatrix;
    elseif options.Transmission == false && options.Torque == true
        TorqueMatrixL = TorqueZeroTemp(totalSystem, totalSysDeriv, gammaL);
        TorqueMatrixR = TorqueZeroTemp(totalSystem, totalSysDeriv, gammaR);
        
        varargout{1} = TorqueMatrixL + TorqueMatrixR;
    else
        TransMatrix = TransmissionZeroTemp(totalSystem, gammaL, gammaR);
        TorqueMatrixL = TorqueZeroTemp(totalSystem, totalSysDeriv, gammaL);
        TorqueMatrixR = TorqueZeroTemp(totalSystem, totalSysDeriv, gammaR);
        
        varargout{1} = TransMatrix;
        varargout{2} = TorqueMatrixL + TorqueMatrixR;
    end
end

function [Transmission] = TransmissionZeroTemp(totalSystem, gammaL, gammaR)
    % calculate the Greens Function
    GreensFuncInv = eye(length(totalSystem)) - totalSystem;
    GreensFunc = inv(GreensFuncInv);
    
    % calculate the matrix product
    Transmission = GreensFunc * gammaR * GreensFunc' * gammaL;
end

function [Transmission] = TorqueZeroTemp(totalSystem, totalSysDeriv, gamma)
    % calculate the Greens Function
    GreensFuncInv = eye(length(totalSystem)) - totalSystem;
    GreensFunc = inv(GreensFuncInv);
    
    % calculate the matrix product
    Transmission = totalSysDeriv * GreensFunc * gamma * GreensFunc';
end

%% helping functions
function [Transmissions] = allTrace(Matrix)
    Transmissions = zeros(1, floor(length(Matrix)/2));
    for i = 1:floor(length(Matrix)/2)
        startIndex = i;
        endIndex = length(Matrix) - (i-1);
        matrix = Matrix(startIndex:endIndex, startIndex:endIndex);
        Transmissions(i) = trace(matrix);
    end
end