function [totalSystem, gammaL, gammaR] = makeSystemEM(sample, sizeSample, orderSample, sizeLead, hoppingLead, hoppingsInter, leadVals, options)
arguments
    sample
    sizeSample
    orderSample
    sizeLead
    hoppingLead
    hoppingsInter
    leadVals
    options.check = true
end
    sizeTotal = sizeSample*orderSample + 2*sizeLead;
    sizeSystem = sizeSample + 2*sizeLead;
    sizeCentral = length(sample);
    
    % compute the fermi functions
    fermiFuncLeft = fermiFunction(sizeSystem, leadVals, left=true);
    fermiFuncRight = fermiFunction(sizeSystem, leadVals, right=true);
    if options.check == true
        checkFermi(fermiFuncLeft, fermiFuncRight)
    end
    
    % generate the pseudo Hamiltonians of the leads
    [sigmaL, indicesL] = makeLead(fermiFuncLeft, hoppingLead, sizeSample, orderSample, sizeLead, left=true);
    [sigmaR, indicesR] = makeLead(fermiFuncRight, hoppingLead, sizeSample, orderSample, sizeLead, right=true);

    if all(indicesL == indicesR) && options.check == true
        disp('The indices do match!')
        
        assignin('base','name',n);
    elseif ~all(indicesL == indicesR) && options.check == true
        error('The indices do NOT match!')
    end
    
    % compute the coupling strengths of the leads
    gammaL = -1j*(sigmaL - sigmaL'); %1j*(sigmaL - sigmaL');
    gammaR = -1j*(sigmaR - sigmaR'); %1j*(sigmaR - sigmaR');
    if options.check == true
        checkGamma(gammaL, 'gammaL')
        checkGamma(gammaR, 'gammaR')
    end

    % generate the hopping matrices between the leads and the sample
    interL = makeInter(sizeLead, sizeCentral, hoppingsInter, left=true);
    interR = makeInter(sizeLead, sizeCentral, hoppingsInter, right=true);
    
    % generate the Hamiltonian of the total system
    totalSystem = combineH(sizeLead, sizeCentral, sample, sigmaL, sigmaR, interL, interR);
    if options.check == true
        checkHamiltonian(totalSystem)
    end
end

%% Fermi functions
function [values] = fermiFunction(sizeSystem, leadVals, options)
% calculate the fermi function for the leads
arguments
    sizeSystem
    leadVals
    options.left = false
    options.right = false
end
    [maxVal, decay, offset] = leadVals{:};
    values = zeros(1, sizeSystem);
    for i = 1:sizeSystem
        if options.left == true && options.right == false
            %site = i+1;
            site = i;
        elseif options.left == false && options.right == true
            %site = sizeSystem - i;
            site = sizeSystem - i+1;
        end
        values(i) = 1j * maxVal/(1+exp(decay*(site-offset)));
    end
end

%% functions used in generating the pseudo Hamiltonian
function [lead, varargout] = makeLead(fermiFunc, hopping, sizeSample, orderSample, sizeLead, options)
% generate the pseudo Hamiltonian of the lead
arguments
    fermiFunc
    hopping
    sizeSample
    orderSample
    sizeLead
    options.left = false
    options.right = false
end
    sizeTotal = sizeSample*orderSample + 2*sizeLead;
    sizeLeft = sizeLead;
    sizeRight = sizeTotal - sizeLead;
    
    lead = zeros(sizeTotal, sizeTotal);
    rowSample = zeros(1, sizeTotal);
    % make the top-left part
    for row = 1 : sizeLeft
        for column = 1 : sizeLeft
            if row == column
                rowSample(row) = row;
                lead(row, column) = fermiFunc(rowSample(row));
            elseif abs(row-column) <= 1 && options.left == true && options.right == false
                lead(row, column) = hopping;
            end
        end
    end
    % make the central part
    for row = sizeLeft+1 : sizeRight
        for column = sizeLeft+1 : sizeRight
            if row == column
                rowSample(row) = sizeLeft + ceil((row-sizeLeft)/orderSample);
                lead(row, column) = fermiFunc(rowSample(row));
            end
        end
    end
    % make the bottom-right part
    for row = sizeRight+1 : sizeTotal
        for column = sizeRight+1 : sizeTotal
            if row == column
                rowSample(row) = row - (sizeSample*(orderSample-1));
                lead(row, column) = fermiFunc(rowSample(row));
            elseif abs(row-column) <= 1 && options.left == false && options.right == true
                lead(row, column) = hopping;
            end
        end
    end
    varargout{1} = rowSample;
end

function [inter] = makeInter(sizeLead, sizeCentral, hoppingsInter, options)
% generate the hopping matrix between the lead and the sample
arguments
    sizeLead
    sizeCentral
    hoppingsInter
    options.left = false
    options.right = false
end
    endVal = size(hoppingsInter);
    endVal = endVal(2);
    if options.left == true && options.right == false
        inter = zeros(sizeCentral, sizeLead);
        for i = 1:endVal
            inter(i, end) = hoppingsInter(1, i);
        end
    elseif options.left == false && options.right == true
        inter = zeros(sizeLead, sizeCentral);
        for i = 1:endVal
            test = sizeCentral-endVal+i;
            inter(1, sizeCentral-endVal+i) = hoppingsInter(2, i);
        end
    end
end

function [totalSystem] = combineH(sizeLead, sizeCentral, sample, leadLeft, leadRight, interLeft, interRight)
% combine the different parts of the full system's pseudo Hamiltonian
    % include the leads
    totalSystem = leadLeft + leadRight;
    % include the sample
    sizeTotal = sizeCentral + 2*sizeLead;
    for row = 1 : sizeCentral
        for column = 1 : sizeCentral
            rowTotal = row + sizeLead;
            columnTotal = column + sizeLead;
            if row == column
                totalSystem(rowTotal, columnTotal) = totalSystem(rowTotal, columnTotal) + sample(row, column);
            else
                totalSystem(rowTotal, columnTotal) = sample(row, column);
            end
        end
    end
    % include the hopping matrices
    top = 1:sizeLead;
    mid = sizeLead+1:sizeTotal-sizeLead;
    bottom = sizeTotal-sizeLead+1:sizeTotal;
        % include the left side
    totalSystem(mid, top) = interLeft;
    totalSystem(top, mid) = interLeft.'; %transpose
        % include the right side
    totalSystem(bottom, mid) = interRight;
    totalSystem(mid, bottom) = interRight.'; %transpose
end

%% checking functions
function [] = checkFermi(fermiFuncLeft, fermiFuncRight)
    if fermiFuncLeft == flip(fermiFuncRight)
        disp('The Fermi functions of the leads match!')
    else
        disp('The Fermi functions of the leads do NOT match!')
    end
end

function [] = checkGamma(gamma, name)
    [~, flag] = chol(gamma);
    if flag == 0
        disp([name, ' is symmetric positive definite. Flag = ', num2str(flag)])
    else
        disp([name, ' is not symmetric positive definite. Flag = ', num2str(flag)])
    end
end

function [] = checkHamiltonian(totalSystem)
    Diff = totalSystem - totalSystem';
    Diag = true;
    offDiag = true;
    for i = 1:length(Diff)
        for j = 1:length(Diff)
            if Diff(i,j) ~= 0 %not equal to zero
                if i==j
                    Diag = false;
                else
                    offDiag = false;
                end
            end
        end
    end
    % return the result
    if Diag == true && offDiag == true
        disp('The Hamiltonian is totally hermitian.')
    elseif Diag == true
        disp('The diagonal elements of the Hamiltonian are hermitian.')
    elseif offDiag == true
        disp('The offdiagonal elements of the Hamiltonian are hermitian.')
    else
        disp('No part of the Hamiltonian is hermitian.')
    end
end