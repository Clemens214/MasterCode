function [totalSystem, gammaL, gammaR] = makeSystemEM(sample, sizeSample, orderSample, sizeLead, hoppingLead, hoppingsInter, leadVals, options)
arguments
    sample
    sizeSample
    orderSample
    sizeLead
    hoppingLead
    hoppingsInter
    leadVals
    options.check = true
end
    sizeTotal = sizeSample*orderSample + 2*sizeLead;
    sizeSystem = sizeSample + 2*sizeLead;
    
    % compute the fermi functions
    fermiFuncLeft = fermiFunction(sizeSystem, leadVals, left=true);
    fermiFuncRight = fermiFunction(sizeSystem, leadVals, right=true);
    if options.check == true
        checkFermi(fermiFuncLeft, fermiFuncRight)
    end
    
    % generate the pseudo Hamiltonians of the leads
    sigmaL = makeLead(fermiFuncLeft, hoppingLead, sizeSample, orderSample, sizeLead, left=true);
    sigmaR = makeLead(fermiFuncRight, hoppingLead, sizeSample, orderSample, sizeLead, right=true);
    
    % compute the coupling strengths of the leads
    gammaL = 1j*(sigmaL - sigmaL');
    gammaR = 1j*(sigmaR - sigmaR');

    % generate the hopping matrices between the leads and the sample
    interLeft = 
    
    % generate the Hamiltonian of the total system
    totalSystem = combineH(sample, sigmaL, sigmaR, hoppingInter, sizeLead);
end

%% Fermi functions
function [values] = fermiFunction(sizeSystem, leadVals, options)
% calculate the fermi function for the leads
arguments
    sizeSystem
    leadVals
    options.left = false
    options.right = false
end
    [maxVal, decay, offset] = leadVals{:};
    values = zeros(1, sizeSystem);
    for i = 1:sizeSystem
        if options.left == true && options.right == false
            site = i;
            values(i) = 1j * maxVal/(1+exp(decay*(site-offset)));
        elseif options.left == false && options.right == true
            site = sizeSystem - i + 1;
            values(i) = 1j * maxVal/(1+exp(decay*(site-offset)));
        end
    end
end

%% generate the leads
function [lead, varargout] = makeLead(fermiFunc, hopping, sizeSample, orderSample, sizeLead, options)
% generate the pseudo Hamiltonian of the lead
arguments
    fermiFunc
    hopping
    sizeSample
    orderSample
    sizeLead
    options.left = false
    options.right = false
end
    sizeLeft = sizeLead;
    sizeRight = sizeSample*orderSample + sizeLead;
    sizeTotal = sizeSample*orderSample + 2*sizeLead;
    
    lead = zeros(sizeTotal, sizeTotal);
    rowSample = zeros(1, sizeTotal);
    % make the top-left part
    for row = 1:sizeLeft
        for column = 1:sizeLeft
            if row == column
                rowSample(row) = row;
                lead(row, column) = fermiFunc(rowSample(row));
            elseif abs(row-column) <= 1 && options.left == true && options.right == false
                lead(row, sample) = hopping;
            end
        end
    end
    % make the central part
    for row = sizeLeft+1:sizeRight
        for column = sizeLeft+1:sizeRight
            if row == column
                rowSample(row) = sizeLeft + ceil((row-sizeLeft)/orderSample);
                lead(row, column) = fermiFunc(rowSample(row));
            end
        end
    end
    % make the bottom-right part
    for row = sizeRight+1:sizeTotal
        for column = sizeRight+1:sizeTotal
            if row == column
                rowSample(row) = row - (sizeSample*(orderSample-1));
                lead(row, column) = fermiFunc(rowSample);
                rowSample(row) = rowSample;
            elseif abs(row-column) <= 1 && options.left == false && options.right == true
                lead(row, sample) = hopping;
            end
        end
    end
    varargout{1} = rowSample;
end

function [inter] = makeInter(sizeLead, sizeCentral, hoppingsInter, options)
% generate the hopping matrix between the lead and the sample
arguments
    sizeLead
    sizeCentral
    hoppingsInter
    options.left = false
    options.right = false
end
    endVal = size(hoppingsInter);
    endVal = endVal(2);
    if options.left == true && options.right == false
        inter = zeros(sizeLead, sizeCentral);
        for i = 1:endVal
            inter(i, end) = hoppingsInter;
        end
    elseif options.left == false && options.right == true
        inter = zeros(sizeCentral, );
        for i = 1:endVal
            inter(i, end) = hoppingsInter;
        end
    end
end

%%
function [arrayNew] = combineH(center, left, right, hoppingInter, size)
    sizeCenter = length(center);
    sizeLeft = length(left);
    sizeRight = length(right);
    sizeMax = max([sizeCenter, sizeLeft, sizeRight]);
    arrayNew = zeros(sizeMax, sizeMax);
    for row = size-1 : sizeMax-size
        for column = size-1 : sizeMax-size
           if row-size > 0 && column-size > 0
               arrayNew(row, column) = center(row-size, column-size);
           end
        end
    end
    values = [size, sizeMax-size];
    for row = 1:sizeMax
       for column = 1:sizeMax
            newFactor = 0;
            if row == values(1) && column == values(1)+1
                newFactor = hoppingInter;
            elseif row == values(1)+1 && column == values(1)
                newFactor = hoppingInter;
            end
            if row == values(2) && column == values(2)+1
                newFactor = hoppingInter;
            end
            if row == values(2)+1 && column == values(2)
                newFactor = hoppingInter;
            end
            arrayNew(row, column) = arrayNew(row, column) + left(row, column) + right(row, column) + newFactor;
        end
    end
end

%% checking functions
function [] = checkFermi(fermiFuncLeft, fermiFuncRight)
    if fermiFuncLeft == flip(fermiFuncRight)
        disp('The Fermi functions of the leads match!')
    else
        disp('The Fermi functions of the leads do NOT match!')
    end
end